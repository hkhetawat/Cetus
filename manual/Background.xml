<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:mml="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xml:id="Background">
    <title>Background</title>
    <para>From a substantial list of compiler infrastructures, we choose to
    discuss three open-source projects that most closely match our goals. The
    goals are to create a source-to-source infrastructure that supports C and
    is extensible to other languages. The three projects are the GNU, Polaris,
    and SUIF compilers. We explain our reasons for not using these
    infrastructures as our basis, and also discuss important features of these
    compilers that we want to adopt in Cetus.</para>

    <sect1>
      <title>GCC</title>

      <para>GCC is one of the most robust compiler infrastructures available
      to the research community. GCC generates highly-optimized code for a
      variety of architectures, which rivals in many cases the quality
      generated by the machine vendor's compiler. Its open-source distribution
      and continuous updates make it attractive. However, GCC was not designed
      for source-to-source transformations. Most of its passes operate on the
      lower-level RTL representation. Only recent versions of GCC (version 3.0
      onward) include an actual syntax tree representation, which has been
      used in Purdue class projects for implementing a number of compiler
      passes. Other limitations are GCC compiles one source file at a time,
      performs separate analysis of procedures, and requires extensive
      modification to support interprocedural analysis across multiple
      files.</para>

      <para>The most difficult problem faced by the students was that GCC does
      not provide a friendly API for pass writers. The API consists largely of
      macros. Passes need to be written in C and operations lack logical
      grouping (classes, namespaces, etc), as would be expected from a
      compiler developed in an object-oriented language.</para>

      <para>GCC's IR has an ad-hoc type system, which is not reflected in its
      implementation language (C). The type system is encoded into integers
      that must be decoded and manipulated by applying a series of macros. It
      is difficult to determine the purpose of fields in the IR from looking
      at the source code, since in general every field is represented by the
      same type. This also makes it difficult for debuggers to provide
      meaningful information to the user.</para>

      <para>Documentation for GCC is abundant. The difficulty is that the
      sheer amount easily overwhelms the user. Generally, we have found that
      there is a very steep learning curve in modifying GCC, with a big time
      investment to implement even trivial transformations.</para>

      <para>The above difficulties were considered primarily responsible for
      the students that used GCC proceeding more slowly than those creating a
      new compiler design. The demonstrated higher efficiency of
      implementation was the ultimate reason for the decision to pursue the
      full design of Cetus.</para>
    </sect1>

    <sect1>
      <title>Polaris</title>

      <para>The Polaris compiler, which we have co-developed in prior work,
      was an important influence on the design of our new infrastructure.
      Polaris is written in C++ and operates on Fortran 77 programs. So far,
      no extensions have been made to handle Fortran 90, which provides a
      user-defined type system and other modern programming language features.
      Polaris' IR is Fortran-oriented and extending it to other languages
      would require substantial modification.</para>

      <para>Another factor we considered was that Polaris was written before
      the Standard Template Library (C++ STL) became available, so it includes
      its own container implementations. It uses a pre-ISO dialect of C++
      which now seems unusual to programmers and causes many warnings (and
      sometimes errors) with current compilers. Both aspects limit its
      portability to other platforms.</para>

      <para>In general, Polaris is representative of compilers that are
      designed for one particular language, serve their purpose well, but are
      difficult to extend. Cetus should not be thought of as "Polaris for C"
      because it is designed to avoid that problem. However, there are still
      several Polaris features that we wanted to adopt in Cetus. Polaris' IR
      can be printed in the form of code that is similar to the source
      program. This property makes it easy for a user to review and understand
      the steps involved in Polaris-generated transformations. Also, Polaris'
      API is such that the IR is in a consistent state after each call. Common
      mistakes that pass writers make can be avoided in this way.</para>
    </sect1>

    <sect1>
      <title>SUIF</title>

      <para>The SUIF compiler is part of the National Compiler Infrastructure
      (NCI), along with Zephyr, whose design began almost a decade ago. The
      infrastructure was intended as a general compiler framework for multiple
      languages. It is written in C++, like Polaris, and the currently
      available version supports analysis of C programs. SUIF 1 is a
      parallelizing compiler and SUIF 2 performs interprocedural
      analysis.</para>

      <para>Both SUIF and Cetus fall into the category of extensible
      source-to-source compilers, so at first SUIF looked like the natural
      choice for our infrastructure. Three main reasons eliminated our pursuit
      of this option. The first was the perception that the project is no
      longer active - the last major release was in 2001 and does not appear
      to have been updated recently. The second reason was, although SUIF
      intends to support multiple languages, we could not find complete front
      ends other than for C and an old version of Java. Work began on front
      ends for Fortran and C++, but they are not available in the current
      release. Hence, as is, SUIF essentially supports a single language, C.
      Finally, we had a strong preference for using Java as the compiler
      implementation language. Java offers several features conducive to good
      software engineering. It provides good debugging support, high
      portability, garbage collection (contributing to the ease of writing
      passes), and its own automatic documentation system. These facts
      prompted us to pursue other compiler infrastructures.</para>
    </sect1>
  </chapter>
